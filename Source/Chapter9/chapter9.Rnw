% Chapter Chapter 9 For Reproducible Research in R and RStudio
% Christopher Gandrud
% Created: 16/07/2012 05:45:03 pm CEST
% Updated: 

\chapter{Chapter 9: Showing Results with Tables}

Graphs and other visual methods, discussed in the next chapter, can
often be a more effective way to present results than tables.\footnote{This
  is especially true of the small-print, high-density coefficient
  estimate tables that are sometimes descriptively called `train
  schedule' tables.} Nonetheless, tables of results, descriptive statistics,
and so on can sometimes be an important part of communicating
research findings.

Creating tables by hand can be tedious no matter what program you are
using to type up your results. Even more tedious is making changes to
hand-created tables when you make changes to your data and models.
Creating these tables can actually introduce new
errors--post-analysis!--if you incorrectly copy what is in your
R output. This is a very real possibility. The mind can go numb
doing that sort of work. Also, creating tables by hand is not very
reproducible.

Fortunately, we don't actually need to create tables by hand. There are
many ways to have R do the work for us. The goal of this
chapter is to learn how to how to \textbf{automate table creation} for
documents produced with both \LaTeX and Markdown/HTML. There are a
number of ways to turn R objects into tables written in
\LaTeX or HTML markup. In this chapter I mostly focus on the
\texttt{xtable} and \texttt{texreg} packages. \texttt{xtable} can
created tables for both of these markup languages. \texttt{texreg} only
produces output for \LaTeX. \texttt{knitr} allows us to incorporate
these tables directly into our documents.

\textbf{Warning:} Automating table creation removes the possibility of
adding errors to our analyses by incorrectly copying R output,
which is a big potential problem in hand-created tables. Be warned, it
is not an error free process. We could easily create inaccurate tables
through coding errors. For example, we may incorrectly merge together
columns in so that our id variables no longer match the data they are
supposed to.

So, as always, it is important to `eyeball' the output. Does it make
sense? If we picked a couple values in the R output do the
match what is in our final table? If not, we need to go back to the code
and see where things have gone wrong. With that caveat, lets start
making tables.

\section{Table Basics}

Before getting into the details of how to create tables from R objects we need to first learn how generic tables are created in \LaTeX and Markdown/HTML.

\subsection{Tables in \LaTeX}

\subsection{Tables in Markdown/HTML}

\section{Creating tables from R objects}

\subsection{\texttt{xtable} \& \texttt{texreg} basics with supported
class objects}

\subsubsection{\texttt{xtable} for \LaTeX}

\subsubsection{\texttt{xtable} for Markdown}

\subsection{\texttt{xtable} with non-supported class objects}

{\tt{xtable}} and other commands in similar packages are very convenient for making tables from objects in supported classes.\footnote{To see a full list of classes that {\tt{xtable}} supports type {\tt{methods(xtable)}} into the R console.} With supported class objects {\tt{xtable}} knows where to look for the vectors containing the things--coefficient names, standard errors, and so on--that it needs to create the table. With unsupported classes, however, it doesn't know where to look for these things. We need to help it out. 

{\tt{xtable}} does have a way of dealing with {\tt{matrix}} and {\tt{dataframe}} class objects. The rows of these objects become the rows of the table and the columns become the table columns. So, to create tables with non-supported class objects we need to

\begin{enumerate}
    \item find and extract the information from the unsupported class object that we want in the table, 
    \item convert this information into a matrix or dataframe where the rows and columns of the object correspond to the rows and columns of the table that we want,
    \item use {\tt{xtable}} with this object to create the table.
\end{enumerate}

Imagine that we want to create a results table showing the covariate names, coefficient means, and quantiles for marginal posterior distributions from a Bayesian normal linear regression using the {\tt{zelig}} command \cite{Goodrich2007} and data from the {\emph{swiss}} dataframe.\footnote{This dataframe is loaded by default.} We run our model:

<<Ch9MCMC, message=FALSE, warning=FALSE, tidy=FALSE>>=
# Load required library
library(Zelig)

# Run model
NBModel <- zelig(Examination ~ Education, model = "normal.bayes", 
                    data = swiss, cite = FALSE)

# Find NBModel's class
class(NBModel)
@

Using the {\tt{class}} command we found that the model output object is an {\tt{MCMCZelig}} class object. This class is not supported by {\tt{xtable}}. If we try to create a summary table called {\emph{NBTable}} of the results we will get the following error:

<<Ch9BadTable, echo=FALSE>>=
# Load required library
library(xtable)

# Attempt to create a table with 'NBModel'
NBTable <- xtable(NBModel)
@

With unsupported class objects we have to create the summary ourselves and extract the things that we want from it manually. This is where a good knowledge of vectors comes in handy. 

First, let's create a summary of our output object {\emph{NBModel}}:

<<Ch9MCMCSummary>>=
NBModelSum <- summary(NBModel)
@

We created a new object of the class {\tt{summary.MCMCZelig}}. We're still not there yet as this object contains not just the covariate names and so on but also information we don't want to include in our results table like the formula that we used. The second step is to extract a matrix from inside {\emph{NBModelSum}} called {\emph{summary}} with the component selector ({\tt{\$}}). This matrix is where the things we want in our table are located. I find it easier to work with dataframes, so we'll also convert the matrix into a dataframe.

<<Ch9NBSum>>=
NBSumDataFrame <- data.frame(NBModelSum$summary)
@
%%
\noindent Here is what our model results dataframe looks like:

<<Ch9NBSumDisplay, echo=FALSE>>=
NBSumDataFrame
@

\noindent Now we have a dataframe object that {\tt{xtable}} can handle. After a little cleaning up (see the chapter's source code for more details) we can use {\emph{NBSumDataFrame}} with {\tt{xtable}} as before to create the following table:
\vspace{0.5cm}

<<Ch9NBTable, echo=FALSE, message=FALSE, results='asis'>>=
# Change quantile variable names
library(reshape)
NBSumDataFrame <- rename(NBSumDataFrame, c(X2.5. = "2.5%"))
NBSumDataFrame <- rename(NBSumDataFrame, c(X50. = "50%"))
NBSumDataFrame <- rename(NBSumDataFrame, c(X97.5. = "97.5%"))


# Reorder variables and remove the standard deviation.
NBTable <- NBSumDataFrame[, c("Mean", "2.5%", "50%", "97.5%")]  

# Create table.
xtable(NBTable, caption = "Coefficient Estimates Predicting Examination Scores in Swiss Cantons (1888) Found Using Bayesian Normal Linear Regression")
@

It may take a bit of hunting to find what you want, but a similar process can be used to create tables from objects of virtually any class.\footnote{This process can also be used to create graphics.} Hunting for what you want is generally easier by clicking on the object in RStudio's workspace pane.

\subsection{Basic \texttt{knitr} syntax for tables}

So far we have only looked at how to create \LaTeX and HTML tables from R objects. How can we knit these tables into our presentation documents?

The most important \texttt{knitr} chunk option for showing the markup created by these packages as tables is \texttt{results}. The \texttt{results} option can have three values:

\begin{itemize}
\item
  \texttt{markup},
\item
  \texttt{asis},
\item
  \texttt{hide}.
\end{itemize}
\texttt{hide} clearly hides the results of whatever we have in our code chunk; no results show up.

\section{Tables with \texttt{apsrtable}}


